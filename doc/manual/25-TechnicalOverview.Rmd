# How it Works

`te_parser::evaluate()` uses a simple recursive descent parser to compile your
expression into a syntax tree. For example, the expression `"sin x + 1/4"`
parses as:

![example syntax tree](e1.png)

`te_parser::evaluate()` also automatically prunes constant branches. In this example,
the compiled expression returned by `te_compile()` would become:

![example syntax tree](e2.png)

## Grammar

TinyExpr++ parses the following grammar (from lowest-to-highest operator precedence):

    <list>      =    <expr> {(",", ";" [dependent on locale]) <expr>}
    <expr>      =    <term> {("&" | "|") <term>}
    <expr>      =    <term> {("<>" | "!=" | "=" | "<") | "<=") | ">" | ">=") <term>}
    <expr>      =    <term> {("<<" | ">>") <term>}
    <expr>      =    <term> {("+" | "-") <term>}
    <term>      =    <factor> {("*" | "/" | "%") <factor>}
    <factor>    =    <power> {("^" | "**") <power>}
    <power>     =    {("-" | "+")} <base>
    <base>      =    <constant>
                   | <variable>
                   | <function-0> {"(" ")"}
                   | <function-1> <power>
                   | <function-X> "(" <expr> {"," <expr>} ")"
                   | "(" <list> ")"

In addition, whitespace between tokens is ignored.

Valid variable names consist of a letter followed by any combination
of: letters `a` through `z` or `A` through `Z`, the digits `0` through `9`, and
underscore. Constants can be integers, decimal numbers, or in scientific
notation (e.g., `1e3` for `1000`). A leading zero is not required (e.g., `.5`
for `0.5`).